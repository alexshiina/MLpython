# -*- coding: utf-8 -*-
"""AI_project_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NGvDDgle5y4Vwc7IchDz5DJloGbuyOdJ
"""

#dataset = gtsrb
#model = vst (transformators)
#fullsize model, putting it on the website

import torch
import torchvision
import matplotlib.pyplot
from torch import nn
from torchvision import transforms,datasets

DEVICE = "cuda" if torch.cuda.is_available() else "cpu" #since I am using transformers, standard colab CPU might be not enough, GPU is advised
BATCH_SIZE = 64

# Get the cheatsheet scripts
print("[INFO] Downloading premade functions from GitHub.")
!git clone https://github.com/alexshiina/MLpython
!mv MLpython/CheatSheet .
!rm -rf MLpython
from CheatSheet import Data, Engine

#importing model, weights and transform

weights = torchvision.models.ViT_B_16_Weights.DEFAULT
model = torchvision.models.vit_b_16(weights = weights).to(DEVICE)
transform = weights.transforms()
from torchvision.transforms import functional as F
#checking out transformation
transform

#reacreating transformation, adding some other transforms
train_transforms = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.RandomRotation(15),
    transforms.RandomAffine(degrees=0, translate=(0.1, 0.1)),
    transforms.ColorJitter(brightness=0.2, contrast=0.2),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

test_transforms = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.RandomAffine(degrees=0, translate=(0.1, 0.1)),
    transforms.ColorJitter(brightness=0.2, contrast=0.2),
    transforms.ToTensor(),
    transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
])

#downloading data
train_data = datasets.GTSRB(root = "data",
                            split = 'train',
                            transform = transform,
                            target_transform = None,
                            download = True)
test_data = datasets.GTSRB(root = "data",
                          split = 'test',
                          transform = transform,
                          target_transform= None,
                          download = True)

#making dataloaders to make batches
from torch.utils.data import DataLoader
import os
train_dataloader = DataLoader(dataset = train_data,
                              batch_size = BATCH_SIZE,
                              shuffle = True,
                              num_workers = os.cpu_count()
                              )
test_dataloader = DataLoader(dataset = train_data,
                              batch_size = BATCH_SIZE,
                              shuffle = True,
                              num_workers = os.cpu_count()
                              )

!pip install torchinfo

from torchinfo import summary

summary(model)

# Freeze backbone initially
for param in model.parameters():
    param.requires_grad = False

# Replace classifier head (43 classes for GTSRB)
model.heads = torch.nn.Sequential(
    torch.nn.Linear(768, 512),
    torch.nn.ReLU(),
    torch.nn.Dropout(0.5),
    torch.nn.Linear(512, 43)
)

print(summary(model))

#optimizer = torch.optim.Adam(params = optimizer_grouped_parameters)
loss_fn = torch.nn.CrossEntropyLoss()
#reworked optimizer
optimizer = torch.optim.AdamW(model.parameters(), lr=3e-4, weight_decay=0.01)

torch.cuda.empty_cache()
#training
results = Engine.trainV2(
    model = model,
    train_dataloader = train_dataloader,
    test_dataloader = test_dataloader,
    optimizer = optimizer,
    loss_fn = loss_fn,
    epochs = 5,
    len_epoch = 1,
    device = DEVICE
)

#visualising loss and accuracy
from CheatSheet import Utils
Utils.plot_loss_curves(results)

from pathlib import Path
import torch
#some debugging, initial save_model def from cheatsheet was wrong but it's already fixed
def save_model(model: torch.nn.Module,
               target_dir: str,
               model_name: str):
    """
    Saves a PyTorch model to a target directory.

    Args:
        model: Target model to save.
        target_dir: Directory to save the model to.
        model_name: Filename (must end with ".pth" or ".pt").
    """
    target_dir_path = Path(target_dir)
    target_dir_path.mkdir(parents=True, exist_ok=True)
    assert model_name.endswith((".pth", ".pt")), "Model name must end with '.pt' or '.pth'"
    model_save_path = target_dir_path / model_name

    print(f"[INFO] Saving model to: {model_save_path}")
    torch.save(model.state_dict(), model_save_path)  # Saves state_dict

save_model(model,'model3','model.pth')

torch.cuda.empty_cache()

from pathlib import Path
path = Path('/content/model/model2.pth')
Path.exists(path)

#since i'am doing training in colab and don't have pro version, I had to load state dict and train next day
model.load_state_dict(torch.load(f=path))

# unfreezed layers and trained the whole model
torch.cuda.empty_cache()
for param in model.parameters():
    param.requires_grad = True  # Unfreeze all layers
optimizer = torch.optim.AdamW(model.parameters(), lr=1e-6)  # Lower LR
results = Engine.trainV2(
    model = model,
    train_dataloader = train_dataloader,
    test_dataloader = test_dataloader,
    optimizer = optimizer,
    loss_fn = loss_fn,
    epochs = 1,
    len_epoch = 1,
    device = DEVICE
)

from CheatSheet import Utils
Utils.plot_loss_curves(results)
results

#below are some visualizations and different parts of code
train_data_2 = datasets.GTSRB(
    root = 'data',
    split = 'test',
    transform = transforms.ToTensor(),
    target_transform = None,
    download = True
)

classes = {16:"Zakaz wjazdu ciężarówek",
           1:'Ograniczenie do 30',
           38:'Obowiązkowe obejście w prawo',
           33:'Nakaz skrętu w prawo za znakiem',
           11: 'Skrzyżowanie z drogą podporządkowaną występującą po obu stronach',
           18: 'Inne niebezpieczeństwo',
           12: "Pierwszeństwo",
           25: 'Roboty drogowe',
           35: 'Nakaz jazdy prosto',
           7: 'Ograniczenie do 100',
           23: 'Śliska jezdnia',
           4: 'Ograniczenie do 70',
           9: 'Zakaz wyprzedzania',
           21: 'Niebezpieczne zakręty - pierwszy w lewo',
           20: 'Niebezpieczny zakręt w prawo',
           27: 'Piesi',
           3: 'Ograniczenie do 60',
           13: 'Ustąp pierszeństwa',
           10: 'Zakaz wyprzedzania przez samochody ciężarowe',
           5: 'Ograniczenie do 80',
           17: 'Zakaz wjazdu',
           34: 'Skręt w prawo za znakiem',
           2: 'Ograniczenie do 50',
           8: 'Ograniczenie do 120',
           30:'Oszronienie jezdni',
           24: 'Zwężenie jezdni prawostronne',
           15: 'Zakaz ruchu w obu kierunkach',
           26: 'Sygnały świetlne',
           28:'Dzieci',
           6:'Koniec ograniczenia prędkości',
           14: 'STOP',
           19:'Niebezpieczny zakręt w lewo',
           22:'Nierówna droga',
           29: 'Nie umiem rozpoznac',
           31: 'Zwierzęta dzikie',
           32:'Koniec zakazów',
           36: 'Nakaz jazdy prosto lub w prawo',
           37: 'Nakaz jazdy prosto lub w lewo',
           39:'Obowiązkowe obejście w lewo',
           40: 'Ruch okrężny',
           41: 'Nie umiem rozpoznać - 2',
           42: 'Koniec zakazu wyprzedzania',
           0: 'Ograniczenie do 20'
           }
print(classes[28])
len(classes)

import matplotlib.pyplot as plt
from PIL import Image
import torchvision.transforms as T

def display_image_by_label(dataset, target_label):
    for image_tensor, label in dataset:
        if label == target_label:
            pil_image = T.ToPILImage()(image_tensor)
            plt.imshow(pil_image)
            plt.title(f"Class: {label}")
            plt.axis("off")
            plt.show()
            return  # Stop after finding the first match
    print(f"No image found with label {target_label}")

# Example usage
target_label = 1
classes[30]
display_image_by_label(train_data_2, target_label)

import matplotlib.pyplot as plt
from PIL import Image
import numpy as np
import torchvision.transforms as T

# Get a sample from the dataset
index =78 # Choose any index between 0 and len(train_data_2)-1
image_tensor, label = train_data_2[index]

# Convert tensor to PIL Image
# If you transform includes ToTensor(), reverse it with ToPILImage()
pil_image = T.ToPILImage()(image_tensor)

# Display the image
plt.imshow(pil_image)
plt.title(f"Class: {label}")
plt.axis("off")
plt.show()